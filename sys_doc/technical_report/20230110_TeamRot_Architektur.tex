\documentclass[a4paper, 10pt, conference]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[
	colorlinks=true,
	linkcolor=black,
	anchorcolor=black,
	citecolor=black,
	filecolor=black,
	menucolor=black,
	runcolor=black,
	urlcolor=black
]{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
\usepackage[style=ieee]{biblatex}
\usepackage{rotating}

\addbibresource{references.bib}

\graphicspath{ {./images/} }

\title{\LARGE
\textbf{SGDb: Semantic Video Game Database} \\ Technical Report
}

\author{
\IEEEauthorblockN{Anastasia Chernysheva} \IEEEauthorblockA{\textit{a.chernysheva@oth-aw.de}}\and
\IEEEauthorblockN{Jakob Götz} \IEEEauthorblockA{\textit{j.goetz2@oth-aw.de}}\and
\IEEEauthorblockN{Ardian Imeraj} \IEEEauthorblockA{\textit{a.imeraj@oth-aw.de}}\and
\IEEEauthorblockN{Patrice Korinth} \IEEEauthorblockA{\textit{p.korinth@oth-aw.de}}\and
\IEEEauthorblockN{Philipp Stangl} \IEEEauthorblockA{\textit{p.stangl1@oth-aw.de}}\and
}

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\begin{abstract}
Dieser Technical Report beschreibt die Architektur von SGDb -- eine webbasierte Anwendung mit einer Graphen-basierten Suche von Videospielen.
\end{abstract}

\section{Einführung und Ziele}

In den weiteren Abschnitten des Technical Reports wird zuerst auf die Lösungsstrategie in Abschnitt~\ref{sec:loesungsstrategie} eingegangen.
Im nächsten Abschnitt~\ref{sec:bausteinsicht} wird das Gesamtsystem aus Bausteinsicht beschrieben.
Anschließend wird in Abschnitt~\ref{sec:verteilungssicht} die Verteilungssicht der Anwendung beschrieben.
In Abschnitt~\ref{sec:entwicklungswerkzeuge} werden die angewandten Werkzeuge zur Entwicklung der Anwendung vorgestellt.
Abschließend wird ein Fazit und Ausblick in Abschnitt~\ref{sec:fazit} gegeben.


\section{Lösungsstrategie}\label{sec:loesungsstrategie}

Dieser Abschnitt enthält einen stark verdichteten Architekturüberblick.
Eine Gegenüberstellung der wichtigsten Ziele und Lösungsansätze.


\section{Datenbeschaffung}\label{sec:datenbeschaffung}

Für die Datenbeschaffung wird eine Client-Anfrage an die Endpunkte der IGDB-API \cite{igdb-api} gesendet. 
Als Antwort wird im Anschluss der Bearbeitung ein Datensatz zurückgegeben, der wesentliche Informationen zu einem Spiel 
beinhaltet. Zu den Informationen zählen: Spiele-ID, Spieletitel, Beschreibung, Veröffentlichungsdatum, Genre, 
Spieleplattform, Bewertung, Entwicklername- und Land sowie eine URL des Coverbildes. 

Der Datensatz wird im JSON-Format gespeichert und auf 500 Spiele, die eine hohe Bewertung erzielt haben (>85), reduziert. Begründet wird diese Bedingung durch das Bestreben, einen Datensatz zu erzeugen, der über viele Informationen zu den einzelnen Spielen verfügt.
Der Datensatz weist an mancher Stelle numerische Werte auf, die jedoch nicht informativ wären für einen Durschnittsnutzer. 
So ist das Veröffentlichungsdatum im Unix-Zeitstempel angegeben. Dieser ist auch als "The Epoch" bekannt und zählt die 
Anzahl der vergangenen Sekunden seit 1.Januar 1970 \cite{unix}. Der Standort des Entwicklerunternehmens wird als 
dreistelliger Country-Code definiert, der von der International Organization for Standardization (ISO) entwickelt 
und im ISO-3166 publiziert wurde \cite{iso}. Es wurde eine Funktion implementiert, die die Unix-Zeit in ein reguläres 
Zeitformat \texttt{DD-MM-YYYY} und den ISO-Country-Code in Ländernamen konvertiert. 

Der Datensatz wird anschließend mit „Refine“~\cite{refine} strukturiert und in RDF-Triples (Graphs) umgewandelt. 


\section{Bausteinsicht}\label{sec:bausteinsicht}
Diese Sicht zeigt die statische Zerlegung des Systems in Bausteine sowie deren Beziehungen.

\subsection{Gesamtsystem}\label{subsec:gesamtsystem}
%TODO Bild von Gesamtsystem mit kurzer Beschreibung

\subsection{Datenbank}\label{subsec:datenbank}
Für die Datenverwaltung und Vernetzung der Informationen wird die Ontotext GraphDB \cite{graphdb} verwendet. In Ontotext werden die Daten in Form von RDF-Triplen gespeichert, die aus einem Subjekt, einem Prädikat und einem Objekt bestehen. Diese Triplen werden in sogenannten Repositories gespeichert, die ähnlich wie Tabellen in relationalen Datenbanken organisiert sind.
%TODO Beschreibung relevanter Informationen über die Datenbank, z.B. Aufbau des Repositories, Ontologie, etc.

\subsection{Backend}\label{subsec:backend}

Das Backend ist mit der Programmiersprache Python und dem Framework „FastAPI“~\cite{fastapi} realisiert. Es dient als Schnittstelle zwischen Datenbank und Frontend. Zusätzlich ist es für die Verarbeitung von Ressourcen zuständig. Hierunter fällt die Aufgabe, Daten vom Frontend so aufzubereiten, dass diese für eine Datenbank-Abfrage genutzt werden können. Des Weiteren werden Ergebnisse aus einer Datenbank-Abfrage vom Backend aufbereitet und über einen Endpunkt dem Frontend zur Verfügung gestellt. Das Format der Rückgaben ist bei jedem Endpunkt JSON.
Das Frontend kommuniziert mit dem Backend über eine RESTful-API, die mithilfe des Frameworks implementiert ist.

Folgende Endpunkte, in Tabelle~\ref{tab:api}, stellt die API im Backend für das Frontend zur Verfügung:

\begin{table}[h!]
    \begin{center}
        \caption{Backend-API für das Frontend}
        \label{tab:api}
        \begin{tabular}{|l|l|}
            \textbf{Endpunkt} & \textbf{Beschreibung}\\
            \hline
            \texttt{GET \, /}				& Graphen für Startseite\\
            \texttt{POST /}					& Filter für den Graphen\\
            \texttt{GET /search/\{search\}}	& Suche eines Videospiels\\
            \texttt{GET /detail/\{game\}}	& Detailseite zu Videospiel\\
        \end{tabular}
    \end{center}
\end{table}

Die Startpage Route gibt als key die Jahre beginnend von 1985 bis 2022 zurück. Jeder key enthält als value die Titel, welche in diesem Jahr veröffentlicht wurden.
Die Filter Route gibt, nachdem sie Daten im JSON Format mit den entsprechenden Filtern erhalten hat, einen aktualisierten Graphen zurück, der die angegebenen Filter berücksichtigt. Das Format und die Struktur des Graphen sind identisch mit demjenigen, der von der Startpage zur Verfügung gestellt wird.
Die Search Route verarbeitet eine Suchanfrage und gibt drei Listen zurück. Die erste Liste enthält alle Spieletitel, welche auf die gestellte Suchanfrage zutreffen. Die zweite Liste enthält alle Spieletitel, welche auf die gestellte Suchanfrage zutreffen und im aktuell angezeigten Graphen zu finden sind. Die dritte Liste enthält alle Spieletitel, welche auf die gestellte Suchanfrage zutreffen und nicht im aktuell angezeigten Graphen zu finden sind. Denn durch die Einstellungen der Filter Route kann es passieren, dass gesuchte Spiele nicht im angezeigten Graphen enthalten sind.
Die Detailpage Route gibt alle in der Datenbank gespeicherten Details zu einem Spiel zurück.

Zur Interaktion mit der Datenbank (RDF Triplestore) wird die Python-Bibliothek „SPARQLWrapper“~\cite{sparqlwrapper} genutzt.
Diese dient als Python-Wrapper für SPARQL und ermöglicht so die Ausführung von Queries in der SPARQL-Syntax. Dazu bietet es die Möglichkeit, das Ergebnis in das gewünschte Format zu formatieren, sodass diese Daten leichter in Python weiterverarbeitet werden können. SPARQL selbst ist eine graphenbasierte Query-Sprache, die mit Daten im RDF-Format arbeitet.

Zuerst wird ein Graphenobjekt definiert, über welches der Zugriff auf die Datenbank realisiert wird. Der Rückgabetyp ist auf das JSON-Format festgelegt. Über das definierte Graphenobjekt können nun Abfragen direkt in der Python Datei vollzogen werden. Die Antwort der Abfragen ist eine geschachtelte JSON-Ausgabe, sodass diese noch weiter formatiert wird.

% TODO hier nochmal drüber arbeiten, hat sich viel getan in den Bereich
%Zuerst wird ein Graphenobjekt definiert, das alle Daten aus der Graphdatenbank beinhaltet. Dieses dient als Grundlage für die weiteren Abfragen. Die Abfragen sind in die Wortsuche sowie die unterschiedlichen Filter unterteilt, die nach Datum, Genre, Bewertung, Entwickler und Plattform filtern können. Sie lassen sich beliebig kombinieren. Die Abfragen bekommen die im Frontend festgelegten Argumente und filtern zunächst nach den gewünschten Kriterien und liefern die Videospiel-IRI‘s in Form von Objekten zurück. Entsprechen die Objekte den Anforderungen, werden diese als Subjekte in der nächsten Abfrage genutzt, um alle zugehörigen Prädikate sowie Objekte der Videospiele im JSON-Format zurückzugeben. Diese werden im Frontend für die Darstellung der Knoten sowie für die Inhalte in der Detailseite genutzt.


\subsection{Frontend}\label{subsec:frontend}

Das Frontend ist für die Benutzerschnittstelle verantwortlich.
Hauptbestandteile des Frontends sind die Suchmaske, der Graph und die Detailseite zu einem Videospiel.
Die Interaktion mit dem Backend erfolgt über die REST-Schnittstelle.

\subsubsection{Graphen Layout}

Für die Darstellung des Graphen und die Interaktion mit diesem wird „Sigma.js“~\cite{sigma} verwendet.
Sigma.js rendert Graphen mit WebGL. Damit lassen sich größere Graphen schneller zeichnen als mit Canvas- oder SVG-basierten Lösungen.
Das Graphenmodell wird in einer separaten Bibliothek namens „Graphology“~\cite{graphology} verwaltet.
Dies ist eine Standardbibliothek mit Algorithmen aus der Graphentheorie und allgemeinen Hilfsprogrammen wie z.B.\ Graphengeneratoren.

Für das Graphen Layout wird der ForceAtlas2 Algorithmus~\cite{forceatlas2} verwendet.
Vor dem Start von ForceAtlas 2 Layout muss die Startposition jedes Knotens festgelegt werden.
Daher müssen zwei Attribute namens x und y für alle Knoten des Diagramms definiert werden.
Dazu wird zuerst ein Graph Objekt erzeugt, das jeden jeden Knoten zufällig positioniert, indem die Koordinaten gleichmäßig nach dem Zufallsprinzip auf dem Intervall [0, 1) ausgewählt werden.

\subsubsection{Suche}
%TODO

\subsubsection{Detailseite}
%TODO


\section{Verteilungssicht}\label{sec:verteilungssicht}

Dieser Abschnitt beschreibt den Betrieb von SGDb. Zentraler Bestandteil der Verteilungsstruktur sind Docker- Container~\cite{docker} (Abbildung~\ref{fig:verteilungssicht}).
Jeder Baustein von SGDb ist für sich isoliert in einem eigenen Docker-Container untergebracht.
Damit das gesamte System mit allen verteilten Komponenten in der korrekten Reihenfolge gestartet wird, werden die Docker- Container mit Docker Compose orchestriert.
Docker Compose übernimmt die Netzwerkkonfiguration und die Vergabe von Host-Namen an die jeweiligen Docker-Container.
Darüber hinaus können Umgebungsvariablen verwaltet werden.

\begin{figure}[thp]
    \centering
    \includegraphics[width=\linewidth]{verteilungssicht}
    \caption{Verteilungssicht}
    \label{fig:verteilungssicht}
\end{figure}


\section{Entwicklungswerkzeuge}\label{sec:entwicklungswerkzeuge}

Dieser Abschnitt geht auf die verwendeten Entwicklungswerkzeuge im Backend (Abschnitt~\ref{subsec:backend-dev-tools}) und Frontend (Abschnitt~\ref{subsec:frontend-dev-tools}) ein.

\subsection{Backend}\label{subsec:backend-dev-tools}

Im Backend wird als Test-Framework „Pytest“~\cite{pytest} genutzt, welches bereits in FastAPI integriert ist.


\subsection{Frontend}\label{subsec:frontend-dev-tools}

Im Frontend wird als Test-Framework „Vitest“~\cite{vitest} in Kombination mit der „Svelte Testing Library“~\cite{stl} verwendet.

\section{Fazit und Ausblick}\label{sec:fazit}

Im Rahmen der Arbeit wurde mit einem begrenzten Datensatz von 500 Spielen eine erste Version der Anwendung entwickelt. Diese ist voll funktionsfähig und erfüllt alle Anforderungen des Fachkonzepts. Zusätzlich konnten einige Optionale-Anforderungen verwirklicht werden. Somit konnte eine bis dato einmalige Anwendung umgesetzt werden.
Die Anwendung ist darauf ausgelegt, auch ohne Komplikationen mit einem größeren Datensatz zu arbeiten.


\printbibliography

\end{document}

